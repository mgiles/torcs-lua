The explanation here relies on an understanding of the Lua/C API. Check out the [Lua reference](www.lua.org/manual/5.1/manual.html) for in-depth documentation on the API (this sample uses Lua 5.1). This is just a quick overview, if you have any questions about the implementation feel free to get in touch.

The generation code for "dispatch.h" and "dispatch.cpp" is in this folder. Some notes:

- "Gen.hs" is the generation script. Dependencies are:
  - GHC (tested on 7.8 but should work with older versions)
  - Haskell packages: aeson, bytestring, text
- Call "Gen" like this: `./Gen "path/to/model" "header_output" "cpp_output"`
  - For example, `./Gen model.json ../dispatch.h ../dispatch.cpp` to overwrite the existing dispatch files
- "Gen.hs" is pretty badly organized, sorry about that. I plan to clean up the generator and separate out the templates
- The code generation is based on "model.json". The model was extracted (mostly manually) from the TORCS header files (ex "car.h", "track.h", "tgf.h")
  - In the JSON, each entry in "structs" corresponds to a TORCS C struct that we want to access from Lua.
  - Every entry in "fields" for a struct corresponds to a struct field we want to access
  - You can see how the different sorts of field get generated by looking at the generated "dispatch.h" and "dispatch.cpp" files.


For details on how the code generation work it's probably best to look at the source for "Gen.hs", and compare the entries in "model.json" to the output in the dispatch files. Here's a quick example though.

In "model.json", check out the entry for `InitCar`. This corresponds to the struct `tInitCar` in "car.h". This has examples for most of the field types:

- `name` is a basic field containing a string. The `type` entry gives the __Lua__ type (`string`). The code generator connects this to the corresponding __C__ type (`char *`)
- `iconColor` is a basic array field. `elemType` gives the type of the array elements. For Lua's `number` type we use the `tdble` type in C (a TORCS typedef for `double`). `length` gives the size of the array.
- `dimension` is a field that is itself a struct, `t3Dd` in this case.
- `wheel` is an array of structs. Each element in this case is a `tWheelSpec` in the C code

In "dispatch.h" the following code is generated for `InitCar` and the `name` field:

- A wrapper type, `tl_InitCar`, that is used as full userdata when we pass the struct pointer to Lua. This lets us only pass the pointer to Lua (rather than copying the full struct). Wrapping the pointer and passing it as full userdata (rather than directly passing the `tInitCar *` as _light_ userdata) lets us attach a metatable and do field dispatch.
- A function signature for dispatching `InitCar` fields: `int dispatch_InitCar(lua_State *L);` in this case
- And entry in the `dispatchers` table: `{"torcs.InitCar", dispatch_InitCar}`. The bridge uses this table to associate userdata with their dispatch tables. The "torcs.InitCar" metatable uses `t_dispatch_InitCar` for its `__index` method. Every time we send a `tl_InitCar` userdata to Lua, it has the "torcs.InitCar" metatable attached.
- Function signatures for each field getter, ex. `int f_InitCar_name(lua_State *L, tInitCar *wrapped);` for the `name` field. These functions return their results on the Lua stack.
- Two convenience typedefs for creating the dispatch table, `getter_InitCar` and `getterEntry_InitCar`
- The dispatch table for fields on this struct, `fields_InitCar`. How this works:
  - Say we have a Lua variable called `initCar` that holds a `tl_InitCar` userdata value
  - We access the `name` field: `initCar.name`
  - The `tl_InitCar` userdata has a metatable whose `__index` method looks up functions in `fields_InitCar`. In this case, "name" is looked up and we get the function `f_InitCar_name`
  - `f_InitCar_name` is called, given the user state and the `tInitCar *` that `initCar` wraps
  - `f_InitCar_name` looks up the `name` field in the struct and puts the result on the Lua stack

For the same `InitCar` struct and fields, the following is generated in "dispatch.cpp"

- The implementation of `dispatch_InitCar`. This function is a Lua-style function and is passed the `tl_InitCar` userdata and the name of the field. It looks up the field in `fields_InitCar` (from "dispatch.h") and calls it to return the correct value.
- The implementation for each field lookup function. For example, `f_InitCar_name` in this file implements the function that's declared in the header. The body of the lookup function depends on the type of the field being looked up:
  - Primitive fields (ex. `int`, `const *`, `tdble`) are just pushed onto the Lua stack
  - Struct fields (ex. `statGC` in `tInitCar`) are wrapped in their full userdata wrapper and have their metatable attached before being pushed
  - Array fields are converted into a Lua table and then pushed
